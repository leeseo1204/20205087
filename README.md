# Linux 프로세스 명령어


## 프로세스 출력 
### `ps`

1) ps 란? 

    리눅스는 다중 사용자, 사용 작업 시스템이기 때문에 여러 개의 프로세스를 동시에 수행하므로 항상 어떤 프로세스들이 실행 되고 있는지 모니터링을 할 필요가 있다. 따라서, ***현재의 시스템에서 실행 중인 프로세스에 관한 정보를 출력하여 사용자에게 정보를 제공하는 명령어*** 이다. 
  
2) 명령어 형태

    `$ ps [옵션]`
     
      | 옵션 |의미|
      |--------- |----|
      |-a|실행중인 전체 사용자의 모든 프로세스 출력|
      |-e|현재 실행 중인 모든 프로세스 정보를 출력|
      |-f|모든 정보를 확인|
      |-u|프로세스를 실행한 사용자와 프로세스 시작 시간등을 출력|
      |-x|터미널 제어 없이 프로세스 현황 보기|
      
     **EXAMPLE**
     
      <img width="417" alt="스크린샷 2022-06-05 00 43 02" src="https://user-images.githubusercontent.com/106860759/172013236-d82f77e3-5d1c-4133-9b2f-f14829636824.png">


      
  
----------------------


 ### `top`     
1) top 란? 

    시스템에서 현재 실행중인 프로세스에 대하 정보를 실시간으로 제공한다.
    
  
2) 명령어 형태

    `$ top [옵션]`
        
      | 옵션 |의미|
      |--------- |----|
      |-n|지정한 숫자만큼 화면 출력을 갱신한후 명|
      |-u|지정한 사용자의 프로세스를 모니터링|
      |-b|출력결과를 파일이나 다른 프로그램으로 전달|
      |-d|화면갱신주기를 초 단위로 설정|
      |-p|지정한 PID 프로세스를 모니터링|


    **EXAMPLE**
 
    <img width="690" alt="스크린샷 2022-06-05 00 47 41" src="https://user-images.githubusercontent.com/106860759/172013507-f023b208-492e-44d4-9f7d-3fead8a3a856.png">

     

     
     
       
## 프로세스 제어 

시그널은 프로세스 사이으 통신수단으로, 어떤 프로세스에 메세지를 보내 프로세스를 제어한다.

**명령어를 실행함으로써 프로세스가 시작되고 그 프로세스를 제어하기 위해서 사전에 정의된 시그널이 존재한다.**


### `kill`

1) kill 이란?

   시그널의 여러개의 종류 중에서 불필요한 프로세스나 잘못 실행된 프로세스를 강제 종료 시킨다.
   
   
2) 명령어 형태

    `$ kill [options] [pid]`
        
      | 옵션 |의미|
      |--------- |----|
      |-l|(영문 L 소문자) : 사용 가능한 시그널 목록을 출력|
      |-1|재실행(SIGHUP)|
      |-9|강제종료(SIGKILL)|
      |-15| 정상 종료(SIGTERM)|
      
        
    **EXAMPLE**
     ```linux
     $ kill -9 PID # PID를 시그널 번호 9(KILL) 전송해서 죽임
    
     $ kill -TERM -1 # 자신이 실행한 모든 프로세스를 종료
     ```
    
     
     




## 프로세스 전환

- foreground : 보통 터미널에서 명령어를 입력하면 명령이 끝날때 까지 다른 명령어를 입력할 수가 없다. 

- background : 반면 백그라운드는 명령어를 입력하면 다른 명령어도 실행이 가능하다. 

### `jobs`

1) jobs 이란?

   현재 돌아가고 있는 ***백그라운드 프로세스 리스트르 모두 출력***  해준다.
   
   백그라운드 프로세스는 스택처럼 쌓이는데, +는 스택의 가장 위에 있다는 뜻이고, -는 바로 그다음 밑에 있다는 뜻이다.
   
   
2) 명령어 형태

    `$ jobs [options] [job name or number]`
    
    | 옵션 |의미|
    |--------- |----|
    |-l|프로세스 그룹 ID를 state 필드 앞에 출력|
    |-n|프로세스 그룹 중에 대표 프로세스 ID를 출력|
    |-p|각 프로세스 ID에 대해 한 행씩 출력|
    |command|지정한 명령어를 실행|
        
        
     **EXAMPLE**
    
    <img width="325" alt="스크린샷 2022-06-05 00 58 21" src="https://user-images.githubusercontent.com/106860759/172013874-5480729c-51e4-4c15-9389-9657642808ef.png">

        
# vim 매크로

1) 매크로 란?

여러 개의 명령을 묶어 하나의 명령으로 만든 것으로  여러 개의 명령을 수행하는 반복적인 작업에서 하나의 매크로 명령만으로 효과적인 작업을 수행할 수 있다.

2) 매크로 기능
 
    | 기능 | 일반모드 | 예제 |
    |--------- |----|-----|
    |녹화|q+(매크로KEY)|qa|
    |녹화 종료|q|q|
    |재생|@+(매크로KEY)|@a|
    |마지막 매크로 실행 |@@|@@|
    |횟수 실행|(횟수)@(매크로KEY)|10@a|
    
    **EXAMPLE**
    
   > 아래 예제는 Start file에서 vim 매크로를 이용하여 End file 처럼 바꾸는 문제이다.
    -----
   `Start file`
    ```c
    package vars
     
    var (
            Version string
            Debug bool
    )
     ```
      `End file`
      ```c
     package vars
     
     var (
            // Version TODO
            Version string
            // Debug TODO
            Debug bool
     )
     ```
     
   -------
    ``` vim
    [답]
    :Gqa<Up>O// <C-N> TODO<Esc>q@azz

    [해설]
    예제를 분석하면 // Verison TODO // Debug TODO가 추가 됨을 확인할수 있다.

    1. 파일의 마지막줄로 이동하는 단축어 G사용하여 마지막줄로 이동한다.
    2. 매크로를 실행하기 위해 qa눌러 녹화를 시작한다.
    3. Debug bool 윗문장에 입력하기 위해서는 방향키이용 하여 위로 한번 누르고  
    4. 현재 라인을 다음줄로 밀고 입력 모드를 시작하는 O를 이용하여  debug bool 위에
    5. //를 입력후 한칸 띄고 ctrl + n을 활용해 Debug를 입력후
    6. esc를 눌러 입력모드를 종료하고  q를 활용하여 메크로 기록을 끝낸다.
    7. @+a를 이용해 매크로 반복을 실행하여 // Version TODO가 입력된걸 확인후
    8. ZZ를 활용해 저장후 종료 한다.
    ```
